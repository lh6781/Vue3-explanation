import { ComponentInternalInstance } from './component'
import { devtoolsComponentUpdated } from './devtools'
import { setBlockTracking } from './vnode'

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 * `currentRenderingInstance` 是一个变量，用于存储当前正在进行渲染的组件实例对象。它被初始化为 `null`。

在 Vue 的渲染过程中，当一个组件实例正在被渲染时，会将该组件实例赋值给 `currentRenderingInstance`，表示当前正在进行渲染的组件实例。当渲染完成后，会将 `currentRenderingInstance` 重置为 `null`。

这个变量主要用于开发环境下的警告和错误提示。在开发环境下，当访问组件实例的某些属性时，会进行一些检查和校验。如果在渲染过程之外访问了某个属性，或者访问了不存在的属性，就会发出相应的警告。而这些警告和错误提示需要知道当前的渲染实例，因此使用 `currentRenderingInstance` 来记录它。

需要注意的是，`currentRenderingInstance` 是一个可变的全局变量，因此在多个地方同时渲染组件时需要小心使用，避免出现意外的覆盖或混淆。一般情况下，Vue 内部会确保正确地维护和更新这个变量，开发者无需手动干预。
 */
export let currentRenderingInstance: ComponentInternalInstance | null = null
/**
 * `currentScopeId` 是一个变量，用于存储当前正在进行渲染的组件的作用域 ID。它被初始化为 `null`。

作用域 ID 是用于在组件样式中生成唯一的 CSS 类名或 CSS 作用域选择器的标识符。在 Vue 的编译过程中，每个组件都会被赋予一个唯一的作用域 ID，以确保组件样式之间的隔离性。

在组件的渲染过程中，当一个组件正在被渲染时，会将该组件的作用域 ID 赋值给 `currentScopeId`，表示当前正在进行渲染的组件的作用域 ID。当渲染完成后，会将 `currentScopeId` 重置为 `null`。

这个变量主要用于编译器和渲染器生成正确的作用域样式。通过 `currentScopeId`，可以在编译器将组件的样式转换为具有唯一类名或作用域选择器的 CSS 规则，确保组件样式之间的隔离。

需要注意的是，`currentScopeId` 是一个可变的全局变量，因此在多个地方同时渲染组件时需要小心使用，避免出现意外的覆盖或混淆。一般情况下，Vue 内部会确保正确地维护和更新这个变量，开发者无需手动干预。
 */
export let currentScopeId: string | null = null

/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 * `setCurrentRenderingInstance` 函数用于在组件渲染过程中设置当前的渲染实例。它接受一个 `ComponentInternalInstance` 类型的实例作为参数，并返回先前设置的渲染实例。

函数的工作原理如下：

1. 将当前的渲染实例保存在变量 `prev` 中，以便稍后返回。
2. 更新 `currentRenderingInstance` 变量为提供的 `instance` 参数，表示当前正在渲染的组件。
3. 根据 `instance.type` 的 `__scopeId` 属性设置 `currentScopeId`。如果 `instance` 为 `null` 或 `instance.type` 没有 `__scopeId`，则将 `currentScopeId` 设置为 `null`。
4. 如果开启了兼容模式 (`__COMPAT__`)，并且 `currentScopeId` 为空，则将其设置为 `instance.type` 的 `_scopeId` 属性。这是为了兼容预编译的 v2 组件，因为它们使用 `_scopeId` 而不是 `__scopeId`。

通过这个函数，我们可以跟踪当前正在进行渲染的组件实例，以及当前渲染实例的作用域 ID。
 */
export function setCurrentRenderingInstance(
  instance: ComponentInternalInstance | null
): ComponentInternalInstance | null {
  const prev = currentRenderingInstance
  currentRenderingInstance = instance
  currentScopeId = (instance && instance.type.__scopeId) || null
  // v2 pre-compiled components uses _scopeId instead of __scopeId
  if (__COMPAT__ && !currentScopeId) {
    currentScopeId = (instance && (instance.type as any)._scopeId) || null
  }
  return prev
}

/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 * `pushScopeId` 函数用于将作用域 ID (`id`) 推入作用域栈中，更新当前的作用域 ID。

函数的工作原理如下：

1. 将提供的作用域 ID (`id`) 赋值给 `currentScopeId` 变量，更新当前的作用域 ID。

通过这个函数，我们可以在组件渲染过程中动态地推入和弹出作用域 ID，以适应嵌套组件的作用域切换。
 */
export function pushScopeId(id: string | null) {
  currentScopeId = id
}

/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * `popScopeId` 函数用于从作用域栈中弹出作用域 ID，恢复到上一个作用域。

函数的工作原理如下：

1. 将 `currentScopeId` 变量设置为 `null`，表示将作用域 ID 弹出作用域栈，恢复到上一个作用域。

通过这个函数，我们可以在组件渲染过程中动态地推入和弹出作用域 ID，以适应嵌套组件的作用域切换。当不再需要当前作用域 ID 时，可以使用 `popScopeId` 函数将其弹出，恢复到上一个作用域。
 * @private
 */
export function popScopeId() {
  currentScopeId = null
}

/**
 * Only for backwards compat
 * @private
 * `withScopeId` 是一个函数，它接收一个字符串 `_id` 作为参数，并返回 `withCtx` 函数。

`withScopeId` 的作用是为虚拟节点创建一个新的上下文，在这个上下文中包含了指定的作用域 ID。

具体来说，`withScopeId` 函数会将 `withCtx` 函数作为结果返回，这个函数用于创建包装了指定作用域 ID 的上下文的虚拟节点。

在 Vue 3 的编译器中，当编译器处理带有作用域 ID 的组件时，会将 `withScopeId` 函数应用于组件的模板代码，以确保在渲染期间使用正确的作用域 ID。
 */
export const withScopeId = (_id: string) => withCtx
/**
 * `ContextualRenderFn` 是一个类型别名，它描述了一个具有特定属性的函数类型。

该函数类型具有以下属性：

- `(...args: any[]): any`: 函数可以接收任意数量的参数，并返回任意类型的值。
- `_n: boolean`: 表示函数的参数是否已经进行了规范化处理。
- `_c: boolean`: 表示函数是否已经编译。
- `_d: boolean`: 表示函数是否禁用了追踪（tracking）功能。
- `_ns: boolean`: 表示函数是否是非作用域（non-scoped）的。

通过使用 `ContextualRenderFn` 类型，可以定义具有上述属性的函数，并对其进行类型检查和推断。
 */
export type ContextualRenderFn = {
  (...args: any[]): any
  _n: boolean /* already normalized */
  _c: boolean /* compiled */
  _d: boolean /* disableTracking */
  _ns: boolean /* nonScoped */
}

/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 * `withCtx` 函数用于包装一个函数，并为其提供上下文环境。

函数签名如下：

```typescript
function withCtx(
  fn: Function,
  ctx: ComponentInternalInstance | null = currentRenderingInstance,
  isNonScopedSlot?: boolean
): ContextualRenderFn
```

- `fn`: 要包装的函数。
- `ctx`: 函数的上下文环境，默认为 `currentRenderingInstance`，即当前渲染的组件实例。
- `isNonScopedSlot`（仅适用于 `__COMPAT__` 模式）：标志是否是非作用域插槽。

`withCtx` 函数返回一个经过包装的函数，该函数具有以下特性：

- 如果没有提供上下文环境 `ctx`，直接返回原始函数 `fn`。
- 如果原始函数已经进行过规范化处理（通过 `_n` 属性标记），直接返回原始函数 `fn`。
- 返回一个新的函数 `renderFnWithContext`，它接受任意数量的参数。
- 在执行 `renderFnWithContext` 之前，会根据上下文环境设置当前渲染实例。
- 执行原始函数 `fn` 并将其结果存储在 `res` 中。
- 在执行完 `renderFnWithContext` 后，恢复之前的渲染实例，并根据需要启用或禁用块跟踪。
- 如果处于开发环境或启用了生产环境的开发工具支持，则调用 `devtoolsComponentUpdated`。
- 返回 `res`，即原始函数 `fn` 的执行结果。

此外，`renderFnWithContext` 还具有以下属性：

- `_n: boolean`：标记函数已经进行过规范化处理。
- `_c: boolean`：标记函数已经编译。
- `_d: boolean`：标记函数是否禁用了块跟踪。
- `_ns: boolean`（仅适用于 `__COMPAT__` 模式）：标志函数是否是非作用域插槽。

通过调用 `withCtx` 函数，可以为函数提供上下文环境，并确保它在正确的渲染实例中执行。这对于处理插槽函数等情况非常有用。
 */
export function withCtx(
  fn: Function,
  ctx: ComponentInternalInstance | null = currentRenderingInstance,
  isNonScopedSlot?: boolean // __COMPAT__ only
) {
  if (!ctx) return fn

  // already normalized
  if ((fn as ContextualRenderFn)._n) {
    return fn
  }

  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1)
    }
    const prevInstance = setCurrentRenderingInstance(ctx)
    let res
    try {
      res = fn(...args)
    } finally {
      setCurrentRenderingInstance(prevInstance)
      if (renderFnWithContext._d) {
        setBlockTracking(1)
      }
    }

    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {
      devtoolsComponentUpdated(ctx)
    }

    return res
  }

  // mark normalized to avoid duplicated wrapping
  renderFnWithContext._n = true
  // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.
  renderFnWithContext._c = true
  // disable block tracking by default
  renderFnWithContext._d = true
  // compat build only flag to distinguish scoped slots from non-scoped ones
  if (__COMPAT__ && isNonScopedSlot) {
    renderFnWithContext._ns = true
  }
  return renderFnWithContext
}
