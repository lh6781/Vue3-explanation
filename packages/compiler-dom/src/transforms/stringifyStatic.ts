/**
 * This module is Node-only.
 */
import {
  NodeTypes,
  ElementNode,
  TransformContext,
  TemplateChildNode,
  SimpleExpressionNode,
  createCallExpression,
  HoistTransform,
  CREATE_STATIC,
  ExpressionNode,
  ElementTypes,
  PlainElementNode,
  JSChildNode,
  TextCallNode,
  ConstantTypes
} from '@vue/compiler-core'
import {
  isVoidTag,
  isString,
  isSymbol,
  isKnownHtmlAttr,
  escapeHtml,
  toDisplayString,
  normalizeClass,
  normalizeStyle,
  stringifyStyle,
  makeMap,
  isKnownSvgAttr,
  isBooleanAttr
} from '@vue/shared'
import { DOMNamespaces } from '../parserOptions'
/**
 * `StringifyThresholds` 是一个枚举（`enum`），用于定义字符串化阈值（stringify thresholds）的常量。

该枚举定义了两个常量：

1. `ELEMENT_WITH_BINDING_COUNT`：表示具有绑定的元素数量的阈值。当元素上具有的绑定数量超过该阈值时，字符串化过程可能会更加复杂和冗长。

2. `NODE_COUNT`：表示节点数量的阈值。当节点的数量超过该阈值时，字符串化过程可能会更加复杂和冗长。

通过将这些阈值定义为常量，可以在代码中使用具有描述性的名称来引用它们，而不必直接使用魔术数值。这样可以提高代码的可读性和可维护性，并且可以方便地在需要调整阈值时进行修改。
 */
export const enum StringifyThresholds {
  ELEMENT_WITH_BINDING_COUNT = 5,
  NODE_COUNT = 20
}
/**
 * `StringifiableNode` 是一个类型别名（type alias），用于表示可以被字符串化的节点（node）类型。

该类型别名包含两个节点类型：

1. `PlainElementNode`：表示普通的元素节点，可以包含属性、子节点等信息。

2. `TextCallNode`：表示文本节点，用于处理动态文本内容。

通过将这些节点类型定义为类型别名，可以在代码中使用 `StringifiableNode` 来指代这些节点类型，从而增加代码的可读性和可维护性。
 */
type StringifiableNode = PlainElementNode | TextCallNode

/**
 * Regex for replacing placeholders for embedded constant variables
 * (e.g. import URL string constants generated by compiler-sfc)
 * `expReplaceRE` 是一个正则表达式（regular expression），用于匹配字符串中的 `__VUE_EXP_START__` 和 `__VUE_EXP_END__` 之间的内容。

具体来说，它的作用是查找字符串中以 `__VUE_EXP_START__` 开始、以 `__VUE_EXP_END__` 结束的内容，并提取其中的内容作为匹配结果。这样的匹配结果可以用于后续的处理或替换操作。

在正则表达式中，`__VUE_EXP_START__` 和 `__VUE_EXP_END__` 部分被使用了双下划线包裹，且前后加上了两个反斜杠（`\\`），这是为了确保它们在字符串中的匹配是字面匹配，而不是正则表达式的特殊字符。

通过使用 `/g` 标志，正则表达式将会查找字符串中所有符合匹配规则的内容，并返回所有匹配结果。
 */
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g

/**
 * Turn eligible hoisted static trees into stringified static nodes, e.g.
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 *
 * A single static vnode can contain stringified content for **multiple**
 * consecutive nodes (element and plain text), called a "chunk".
 * `@vue/runtime-dom` will create the content via innerHTML in a hidden
 * container element and insert all the nodes in place. The call must also
 * provide the number of nodes contained in the chunk so that during hydration
 * we can know how many nodes the static vnode should adopt.
 *
 * The optimization scans a children list that contains hoisted nodes, and
 * tries to find the largest chunk of consecutive hoisted nodes before running
 * into a non-hoisted node or the end of the list. A chunk is then converted
 * into a single static vnode and replaces the hoisted expression of the first
 * node in the chunk. Other nodes in the chunk are considered "merged" and
 * therefore removed from both the hoist list and the children array.
 *
 * This optimization is only performed in Node.js.
 * `stringifyStatic` 是一个函数，它是一个 `HoistTransform` 类型的转换函数。它接收 `children`、`context` 和 `parent` 作为参数，并在转换过程中对静态节点进行字符串化。

函数的主要逻辑如下：

1. 首先检查当前是否在处理插槽内容（`context.scopes.vSlot > 0`），如果是，则不进行字符串化，直接返回。

2. 初始化当前节点数量 `nc` 和具有绑定的元素数量 `ec`，以及一个空数组 `currentChunk` 用于存储当前符合条件的节点。

3. 定义 `stringifyCurrentChunk` 函数，用于将当前符合条件的节点组合成单个静态 vnode 调用。在达到一定数量阈值时，会使用 `createCallExpression` 创建静态 vnode 调用，并替换第一个节点的 hoisted 表达式为静态 vnode 调用。同时，对于合并的节点，将它们的 hoisted 表达式设置为 null，并从 `children` 数组中移除。

4. 使用循环遍历 `children` 数组中的节点。

5. 如果节点存在 hoisted 表达式，则说明它是可字符串化的节点，将其记录到 `currentChunk` 数组中，并调用 `analyzeNode` 分析节点。如果分析结果为真，则表示节点是可字符串化的，更新 `nc` 和 `ec` 的计数，并继续处理下一个节点。

6. 如果遇到不可字符串化的节点，则调用 `stringifyCurrentChunk` 函数对当前的符合条件的节点进行字符串化处理，并根据返回的删除数量调整循环的迭代索引。同时重置 `nc`、`ec` 和 `currentChunk` 的状态。

7. 在循环结束后，调用 `stringifyCurrentChunk` 函数处理最后一批符合条件的节点。

总体来说，`stringifyStatic` 函数的作用是将连续的符合条件的静态节点组合成一个静态 vnode 调用，并将原始的节点替换为静态 vnode 调用，以减少运行时的计算和处理。这样可以优化渲染性能，并减少生成的代码大小。
 */
export const stringifyStatic: HoistTransform = (children, context, parent) => {
  // bail stringification for slot content
  if (context.scopes.vSlot > 0) {
    return
  }

  let nc = 0 // current node count
  let ec = 0 // current element with binding count
  const currentChunk: StringifiableNode[] = []

  const stringifyCurrentChunk = (currentIndex: number): number => {
    if (
      nc >= StringifyThresholds.NODE_COUNT ||
      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
    ) {
      // combine all currently eligible nodes into a single static vnode call
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map(node => stringifyNode(node, context)).join('')
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(currentChunk.length)
      ])
      // replace the first node's hoisted expression with the static vnode call
      replaceHoist(currentChunk[0], staticCall, context)

      if (currentChunk.length > 1) {
        for (let i = 1; i < currentChunk.length; i++) {
          // for the merged nodes, set their hoisted expression to null
          replaceHoist(currentChunk[i], null, context)
        }

        // also remove merged nodes from children
        const deleteCount = currentChunk.length - 1
        children.splice(currentIndex - currentChunk.length + 1, deleteCount)
        return deleteCount
      }
    }
    return 0
  }

  let i = 0
  for (; i < children.length; i++) {
    const child = children[i]
    const hoisted = getHoistedNode(child)
    if (hoisted) {
      // presence of hoisted means child must be a stringifiable node
      const node = child as StringifiableNode
      const result = analyzeNode(node)
      if (result) {
        // node is stringifiable, record state
        nc += result[0]
        ec += result[1]
        currentChunk.push(node)
        continue
      }
    }
    // we only reach here if we ran into a node that is not stringifiable
    // check if currently analyzed nodes meet criteria for stringification.
    // adjust iteration index
    i -= stringifyCurrentChunk(i)
    // reset state
    nc = 0
    ec = 0
    currentChunk.length = 0
  }
  // in case the last node was also stringifiable
  stringifyCurrentChunk(i)
}
/**
 * 
 * @param node 
 * @returns 
 * `getHoistedNode` 是一个函数，它接收一个 `TemplateChildNode` 类型的参数 `node`，并返回一个布尔值。

该函数用于判断给定的节点是否存在 hoisted 节点。函数的逻辑如下：

1. 首先判断节点的类型是否为 `ELEMENT`（元素节点）并且 `tagType` 属性为 `ELEMENT`，或者节点的类型为 `TEXT_CALL`。

2. 接着判断节点是否具有 `codegenNode` 属性，并且 `codegenNode` 的类型为 `SIMPLE_EXPRESSION`。

3. 最后判断 `codegenNode` 是否具有 `hoisted` 属性。

如果以上条件都满足，则返回 `true`，表示节点存在 hoisted 节点；否则返回 `false`，表示节点不存在 hoisted 节点。

需要注意的是，hoisted 节点是在编译阶段通过静态分析识别的一种优化手段，用于将静态节点提升到上层作用域，以减少运行时的计算和处理。这样可以提高渲染性能和减少生成的代码大小。
 */
const getHoistedNode = (node: TemplateChildNode) =>
  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||
    node.type == NodeTypes.TEXT_CALL) &&
  node.codegenNode &&
  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&
  node.codegenNode.hoisted
/**
 * `dataAriaRE` 是一个正则表达式对象，用于匹配以 "data-" 或 "aria-" 开头的字符串。

该正则表达式的定义为 `/^(data|aria)-/`，具体解释如下：

- `^` 表示匹配字符串的开头。
- `(data|aria)` 表示匹配 "data" 或 "aria"。
- `-` 表示匹配连字符 "-"。
- `/` 表示正则表达式的开始和结束。

因此，`dataAriaRE` 用于判断字符串是否以 "data-" 或 "aria-" 开头，常用于处理与数据属性 (data attribute) 或 ARIA 属性 (ARIA attribute) 相关的操作和处理。
 */
const dataAriaRE = /^(data|aria)-/
const isStringifiableAttr = (name: string, ns: DOMNamespaces) => {
  return (
    (ns === DOMNamespaces.HTML
      ? isKnownHtmlAttr(name)
      : ns === DOMNamespaces.SVG
      ? isKnownSvgAttr(name)
      : false) || dataAriaRE.test(name)
  )
}
/**
 * 
 * @param node 
 * @param replacement 
 * @param context 
 * `replaceHoist` 是一个函数，用于替换节点的 hoisted 表达式。

该函数接受三个参数：
- `node`：要替换 hoisted 表达式的节点，必须是 `StringifiableNode` 类型。
- `replacement`：要替换为的新表达式，可以是 `JSChildNode` 类型或 `null`。
- `context`：转换上下文对象。

函数的主要功能是在转换上下文的 `hoists` 数组中找到要替换的 hoisted 表达式，并将其替换为新的表达式或 `null`。它通过在 `context.hoists` 数组中找到原始 hoisted 表达式并将其替换为新的表达式来实现替换操作。

需要注意的是，函数假设传入的 `node` 具有 `codegenNode` 属性，且 `codegenNode` 是 `SimpleExpressionNode` 类型，并且该 `codegenNode` 具有非空的 `hoisted` 属性。

该函数用于在静态字符串化过程中，将符合条件的节点的 hoisted 表达式替换为新的表达式或 `null`。
 */
const replaceHoist = (
  node: StringifiableNode,
  replacement: JSChildNode | null,
  context: TransformContext
) => {
  const hoistToReplace = (node.codegenNode as SimpleExpressionNode).hoisted!
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
}
/**
 * `isNonStringifiable` 是一个函数，用于检查给定的标签名是否是不可字符串化的。

该函数使用 `makeMap` 工具函数创建了一个映射表，该映射表中的标签名都被认为是不可字符串化的。映射表的键是标签名，值为 `true`。

函数接受一个参数 `tag`，表示要检查的标签名。如果 `tag` 在映射表中存在且对应的值为 `true`，则返回 `true`，表示该标签名是不可字符串化的；否则返回 `false`，表示该标签名可字符串化。

该函数主要用于静态字符串化过程中，用于判断某个标签是否是不可字符串化的，以决定是否跳过该标签的字符串化。
 */
const isNonStringifiable = /*#__PURE__*/ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
)

/**
 * for a hoisted node, analyze it and return:
 * - false: bailed (contains non-stringifiable props or runtime constant)
 * - [nc, ec] where
 *   - nc is the number of nodes inside
 *   - ec is the number of element with bindings inside
 * `analyzeNode` 是一个用于分析节点可字符串化情况的函数。

函数接受一个参数 `node`，表示要分析的节点。该节点可以是 `PlainElementNode` 或 `TextCallNode` 类型的节点。

函数首先检查节点类型，如果节点是 `ElementNode` 并且标签名是不可字符串化的，则返回 `false`，表示该节点不可字符串化。

如果节点是 `TextCallNode`，则返回一个数组 `[1, 0]`，表示节点数为 1，没有带绑定的元素。

接下来，函数初始化节点数 `nc` 为 1，表示当前节点的数量，初始化带绑定的元素数 `ec` 为 0。

然后函数定义了一个内部函数 `walk`，用于遍历节点及其子节点。`walk` 函数会遍历节点的属性，如果属性是非字符串化的绑定（非属性绑定），则返回 `false`，表示节点不可字符串化。如果属性是绑定的属性，则增加带绑定的元素数 `ec`。

接着，函数遍历节点的子节点，对于每个子节点，增加节点数 `nc`。如果子节点是元素节点，则判断其属性数量，如果大于 0，则增加带绑定的元素数 `ec`，然后递归调用 `walk` 函数遍历子节点的子节点。

如果在遍历过程中出现了不可字符串化的情况，函数会返回 `false`，表示节点不可字符串化。否则，函数会返回一个数组 `[nc, ec]`，表示节点数和带绑定的元素数。

该函数用于静态字符串化过程中，用于分析节点的字符串化情况，以便决定是否将节点纳入静态字符串化的处理范围。
 */
function analyzeNode(node: StringifiableNode): [number, number] | false {
  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
    return false
  }

  if (node.type === NodeTypes.TEXT_CALL) {
    return [1, 0]
  }

  let nc = 1 // node count
  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count
  let bailed = false
  const bail = (): false => {
    bailed = true
    return false
  }

  // TODO: check for cases where using innerHTML will result in different
  // output compared to imperative node insertions.
  // probably only need to check for most common case
  // i.e. non-phrasing-content tags inside `<p>`
  function walk(node: ElementNode): boolean {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i]
      // bail on non-attr bindings
      if (
        p.type === NodeTypes.ATTRIBUTE &&
        !isStringifiableAttr(p.name, node.ns)
      ) {
        return bail()
      }
      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
        // bail on non-attr bindings
        if (
          p.arg &&
          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))
        ) {
          return bail()
        }
        if (
          p.exp &&
          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
            p.exp.constType < ConstantTypes.CAN_STRINGIFY)
        ) {
          return bail()
        }
      }
    }
    for (let i = 0; i < node.children.length; i++) {
      nc++
      const child = node.children[i]
      if (child.type === NodeTypes.ELEMENT) {
        if (child.props.length > 0) {
          ec++
        }
        walk(child)
        if (bailed) {
          return false
        }
      }
    }
    return true
  }

  return walk(node) ? [nc, ec] : false
}
/**
 * 
 * @param node 
 * @param context 
 * @returns 
 * `stringifyNode` 是一个用于将节点转换为字符串的函数。

函数接受两个参数：`node` 表示要转换的节点，可以是字符串或 `TemplateChildNode` 类型；`context` 表示转换的上下文信息。

首先，函数检查 `node` 是否是字符串，如果是，则直接返回该字符串。

接着，函数检查 `node` 是否是符号（Symbol），如果是，则返回空字符串。

然后，函数根据节点的类型进行不同的处理：

- 如果节点类型是 `ElementNode`，则调用 `stringifyElement` 函数对元素节点进行字符串化处理。
- 如果节点类型是 `Text`，则对节点内容进行 HTML 转义，然后返回结果。
- 如果节点类型是 `Comment`，则在节点内容两侧添加注释的 HTML 标记，进行 HTML 转义，然后返回结果。
- 如果节点类型是 `Interpolation`，则对插值表达式的内容进行求值、转换为字符串，进行 HTML 转义，然后返回结果。
- 如果节点类型是 `CompoundExpression`，则对复合表达式进行求值、转换为字符串，进行 HTML 转义，然后返回结果。
- 如果节点类型是 `TextCall`，则递归调用 `stringifyNode` 函数对节点的内容进行字符串化处理。
- 对于其他节点类型（如 `If`、`For` 等），由于静态树不会包含这些节点，所以直接返回空字符串。

最后，函数根据节点的类型进行处理，并返回相应的字符串结果。

该函数用于将节点转换为字符串，用于静态字符串化过程中，将节点的内容转换为静态文本。
 */
function stringifyNode(
  node: string | TemplateChildNode,
  context: TransformContext
): string {
  if (isString(node)) {
    return node
  }
  if (isSymbol(node)) {
    return ``
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      return stringifyElement(node, context)
    case NodeTypes.TEXT:
      return escapeHtml(node.content)
    case NodeTypes.COMMENT:
      return `<!--${escapeHtml(node.content)}-->`
    case NodeTypes.INTERPOLATION:
      return escapeHtml(toDisplayString(evaluateConstant(node.content)))
    case NodeTypes.COMPOUND_EXPRESSION:
      return escapeHtml(evaluateConstant(node))
    case NodeTypes.TEXT_CALL:
      return stringifyNode(node.content, context)
    default:
      // static trees will not contain if/for nodes
      return ''
  }
}
/**
 * 
 * @param node 
 * @param context 
 * @returns 
 * `stringifyElement` 是一个用于将元素节点转换为字符串的函数。

函数接受两个参数：`node` 表示要转换的元素节点，类型为 `ElementNode`；`context` 表示转换的上下文信息。

函数首先创建一个空字符串 `res`，用于存储转换后的结果。然后开始遍历元素节点的属性列表。

对于每个属性，函数根据属性的类型进行不同的处理：

- 如果属性类型是 `ATTRIBUTE`，则将属性名和属性值添加到 `res` 中，属性值进行 HTML 转义。
- 如果属性类型是 `DIRECTIVE`，则根据指令的名称进行不同的处理：
  - 如果指令名称是 `'bind'`，则判断表达式的内容是否以 `'_'` 开头，如果是，则表示是内部生成的字符串常量引用（如通过编译器的 SFC 转换插件导入的 URL 字符串），将引用的内容添加到 `res` 中，并在开始和结束处添加特定的标记 `__VUE_EXP_START__` 和 `__VUE_EXP_END__`。
  - 如果指令名称是 `'html'`，则将指令的表达式的内容作为 `innerHTML`。
  - 如果指令名称是 `'text'`，则将指令的表达式的内容求值并转换为字符串，进行 HTML 转义。
- 如果存在 `context.scopeId`，则将其添加到 `res` 中。

接着，将元素节点的起始标签闭合，并根据是否存在 `innerHTML` 决定是否添加 `innerHTML` 到 `res` 中。如果不存在 `innerHTML`，则遍历元素节点的子节点，对每个子节点调用 `stringifyNode` 函数进行字符串化处理，并将结果添加到 `res` 中。

最后，如果元素节点不是自闭合标签，则添加结束标签到 `res` 中。

最终，函数返回生成的字符串结果。

该函数用于将元素节点转换为字符串，包括标签、属性、子节点等信息，并进行相应的 HTML 转义处理。
 */
function stringifyElement(
  node: ElementNode,
  context: TransformContext
): string {
  let res = `<${node.tag}`
  let innerHTML = ''
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      res += ` ${p.name}`
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`
      }
    } else if (p.type === NodeTypes.DIRECTIVE) {
      if (p.name === 'bind') {
        const exp = p.exp as SimpleExpressionNode
        if (exp.content[0] === '_') {
          // internally generated string constant references
          // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
          res += ` ${
            (p.arg as SimpleExpressionNode).content
          }="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`
          continue
        }
        // #6568
        if (
          isBooleanAttr((p.arg as SimpleExpressionNode).content) &&
          exp.content === 'false'
        ) {
          continue
        }
        // constant v-bind, e.g. :foo="1"
        let evaluated = evaluateConstant(exp)
        if (evaluated != null) {
          const arg = p.arg && (p.arg as SimpleExpressionNode).content
          if (arg === 'class') {
            evaluated = normalizeClass(evaluated)
          } else if (arg === 'style') {
            evaluated = stringifyStyle(normalizeStyle(evaluated))
          }
          res += ` ${(p.arg as SimpleExpressionNode).content}="${escapeHtml(
            evaluated
          )}"`
        }
      } else if (p.name === 'html') {
        // #5439 v-html with constant value
        // not sure why would anyone do this but it can happen
        innerHTML = evaluateConstant(p.exp as SimpleExpressionNode)
      } else if (p.name === 'text') {
        innerHTML = escapeHtml(
          toDisplayString(evaluateConstant(p.exp as SimpleExpressionNode))
        )
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`
  }
  res += `>`
  if (innerHTML) {
    res += innerHTML
  } else {
    for (let i = 0; i < node.children.length; i++) {
      res += stringifyNode(node.children[i], context)
    }
  }
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`
  }
  return res
}

// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transforms/transformExpression)
/**
 * 
 * @param exp 
 * @returns 
 * `evaluateConstant` 是一个用于求解常量表达式的函数。

函数接受一个参数 `exp`，表示要求解的表达式节点，类型为 `ExpressionNode`。

函数首先判断表达式节点的类型：
- 如果是 `SIMPLE_EXPRESSION` 类型，说明表达式是一个简单的表达式，直接将表达式的内容作为字符串解析，并通过动态创建一个函数来执行表达式并返回结果。
- 如果是 `COMPOUND_EXPRESSION` 类型，说明表达式是一个复合表达式，需要遍历表达式的子节点来逐个求解，并将结果拼接成一个字符串。

在遍历子节点时，函数对于每个子节点进行不同的处理：
- 如果子节点是字符串或符号，则直接跳过。
- 如果子节点是 `TEXT` 类型，则将其内容拼接到结果字符串中。
- 如果子节点是 `INTERPOLATION` 类型，则递归调用 `evaluateConstant` 函数求解插值表达式，并将结果拼接到结果字符串中。
- 如果子节点是其他类型的表达式节点，则递归调用 `evaluateConstant` 函数求解该表达式，并将结果拼接到结果字符串中。

最终，函数返回求解得到的字符串结果。

该函数用于求解常量表达式，将表达式节点中的内容解析为字符串，并通过动态创建函数来执行表达式并返回结果。对于复合表达式，会递归求解子节点，并将结果拼接成一个字符串。
 */
function evaluateConstant(exp: ExpressionNode): string {
  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return new Function(`return (${exp.content})`)()
  } else {
    // compound
    let res = ``
    exp.children.forEach(c => {
      if (isString(c) || isSymbol(c)) {
        return
      }
      if (c.type === NodeTypes.TEXT) {
        res += c.content
      } else if (c.type === NodeTypes.INTERPOLATION) {
        res += toDisplayString(evaluateConstant(c.content))
      } else {
        res += evaluateConstant(c)
      }
    })
    return res
  }
}
